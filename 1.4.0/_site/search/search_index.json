{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview SmallRye GraphQL is a library that allows you to easily use GraphQL (both server-side endpoints and client-side code) in your Java-based projects. It implements the MicroProfile GraphQL specification.","title":"Overview"},{"location":"#overview","text":"SmallRye GraphQL is a library that allows you to easily use GraphQL (both server-side endpoints and client-side code) in your Java-based projects. It implements the MicroProfile GraphQL specification.","title":"Overview"},{"location":"client_configuration/","text":"Client-side configuration properties TODO","title":"Client configuration"},{"location":"client_configuration/#client-side-configuration-properties","text":"TODO","title":"Client-side configuration properties"},{"location":"dynamic-client-error-handling/","text":"Error handling with dynamic clients When executing GraphQL operations using a dynamic client, the application receives back an instance of io.smallrye.graphql.client.Response that encapsulates the whole response from the service, including potential errors. Errors are represented as io.smallrye.graphql.client.GraphQLError and can be inspected after retrieving a list of all errors using response.getErrors() . It is also possible to convert a response's errors into a io.smallrye.graphql.client.GraphQLClientException by calling throwExceptionIfErrors() - the response has to be cast to ResponseImpl for this as of now. This method will, if there are any errors in the response, convert the errors into a GraphQLClientException and throw it.","title":"Error handling"},{"location":"dynamic-client-error-handling/#error-handling-with-dynamic-clients","text":"When executing GraphQL operations using a dynamic client, the application receives back an instance of io.smallrye.graphql.client.Response that encapsulates the whole response from the service, including potential errors. Errors are represented as io.smallrye.graphql.client.GraphQLError and can be inspected after retrieving a list of all errors using response.getErrors() . It is also possible to convert a response's errors into a io.smallrye.graphql.client.GraphQLClientException by calling throwExceptionIfErrors() - the response has to be cast to ResponseImpl for this as of now. This method will, if there are any errors in the response, convert the errors into a GraphQLClientException and throw it.","title":"Error handling with dynamic clients"},{"location":"dynamic-client-usage/","text":"Dynamic client introduction and basic usage A Java GraphQL client. The main difference from the typesafe client is that while the typesafe client behaves like a typesafe proxy very similar to the MicroProfile REST Client, the dynamic client is more like the JAX-RS client from the javax.ws.rs.client package. Instead of working with model classes directly, the dynamic client focuses on programmatically working with GraphQL documents representing GraphQL requests and responses. It still offers the option to convert between documents and model classes when necessary. In the current implementation, Vert.x HTTP client is used for handling the underlying traffic. Basic Usage Given the following GraphQL service on the server side: @GraphQLApi class SuperHeroesApi { @Query List < SuperHero > allHeroesIn ( String location ) { // .... } } class SuperHero { private String name ; private List < String > superPowers ; } Such service can be queried this way: package examples.dynamicclient ; import examples.typesafeclient.SuperHero ; import io.smallrye.graphql.client.Response ; import io.smallrye.graphql.client.core.Document ; import io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient ; import javax.inject.Inject ; import javax.json.JsonArray ; import java.util.List ; import java.util.concurrent.ExecutionException ; import static io.smallrye.graphql.client.core.Argument.arg ; import static io.smallrye.graphql.client.core.Argument.args ; import static io.smallrye.graphql.client.core.Document.document ; import static io.smallrye.graphql.client.core.Field.field ; import static io.smallrye.graphql.client.core.Operation.operation ; public class MyClientUsage { @Inject DynamicGraphQLClient client ; public void execute () throws ExecutionException , InterruptedException { Document document = document ( // <1> operation ( field ( \"allHeroesIn\" , args ( arg ( \"location\" , \"Outer Space\" )), field ( \"name\" ), field ( \"superPowers\" )))); Response response = client . executeSync ( document ); // <2> JsonArray heroesArray = response . getData (). getJsonArray ( \"allHeroesIn\" ); // <3> List < SuperHero > heroes = response . getList ( SuperHero . class , \"allHeroesIn\" ); // <4> } } <1> Creating the document representing the request. We used static imports to make the code easy to read, they all come from the classes in the io.smallrye.graphql.client.core package. <2> Executing the request. You can either do that in a blocking way, or request a Uni if you prefer the reactive style. <3> Obtaining the resulting list of heroes as a JsonArray . <4> Obtaining the resulting list of heroes as instances of the model class. This is optional, you can continue working with the data as a JsonArray if you prefer. Initializing the client instance There are two ways to obtain a client instance. Using CDI injection where the configuration values are defined in system properties: @Inject @NamedClient ( \"superheroes\" ) DynamicGraphQLClient client ; // assuming that this system property exists: // superheroes/mp-graphql/url=https://superheroes.org/graphql Programmatically using a builder: DynamicGraphQLClient client = DynamicGraphQLClientBuilder . newBuilder () . url ( \"https://superheroes.org/graphql\" ) . build (); Configuration properties These properties apply when you\u2019re using CDI to inject named client instances (the first example in the previous section). CLIENT_NAME/mp-graphql/url - defines the URL where the client should connect CLIENT_NAME/mp-graphql/header/KEY - this property declares that the client will add a HTTP header named KEY to all requests (with a value being the value of this property)","title":"Basic usage"},{"location":"dynamic-client-usage/#dynamic-client-introduction-and-basic-usage","text":"A Java GraphQL client. The main difference from the typesafe client is that while the typesafe client behaves like a typesafe proxy very similar to the MicroProfile REST Client, the dynamic client is more like the JAX-RS client from the javax.ws.rs.client package. Instead of working with model classes directly, the dynamic client focuses on programmatically working with GraphQL documents representing GraphQL requests and responses. It still offers the option to convert between documents and model classes when necessary. In the current implementation, Vert.x HTTP client is used for handling the underlying traffic.","title":"Dynamic client introduction and basic usage"},{"location":"dynamic-client-usage/#basic-usage","text":"Given the following GraphQL service on the server side: @GraphQLApi class SuperHeroesApi { @Query List < SuperHero > allHeroesIn ( String location ) { // .... } } class SuperHero { private String name ; private List < String > superPowers ; } Such service can be queried this way: package examples.dynamicclient ; import examples.typesafeclient.SuperHero ; import io.smallrye.graphql.client.Response ; import io.smallrye.graphql.client.core.Document ; import io.smallrye.graphql.client.dynamic.api.DynamicGraphQLClient ; import javax.inject.Inject ; import javax.json.JsonArray ; import java.util.List ; import java.util.concurrent.ExecutionException ; import static io.smallrye.graphql.client.core.Argument.arg ; import static io.smallrye.graphql.client.core.Argument.args ; import static io.smallrye.graphql.client.core.Document.document ; import static io.smallrye.graphql.client.core.Field.field ; import static io.smallrye.graphql.client.core.Operation.operation ; public class MyClientUsage { @Inject DynamicGraphQLClient client ; public void execute () throws ExecutionException , InterruptedException { Document document = document ( // <1> operation ( field ( \"allHeroesIn\" , args ( arg ( \"location\" , \"Outer Space\" )), field ( \"name\" ), field ( \"superPowers\" )))); Response response = client . executeSync ( document ); // <2> JsonArray heroesArray = response . getData (). getJsonArray ( \"allHeroesIn\" ); // <3> List < SuperHero > heroes = response . getList ( SuperHero . class , \"allHeroesIn\" ); // <4> } } <1> Creating the document representing the request. We used static imports to make the code easy to read, they all come from the classes in the io.smallrye.graphql.client.core package. <2> Executing the request. You can either do that in a blocking way, or request a Uni if you prefer the reactive style. <3> Obtaining the resulting list of heroes as a JsonArray . <4> Obtaining the resulting list of heroes as instances of the model class. This is optional, you can continue working with the data as a JsonArray if you prefer.","title":"Basic Usage"},{"location":"dynamic-client-usage/#initializing-the-client-instance","text":"There are two ways to obtain a client instance. Using CDI injection where the configuration values are defined in system properties: @Inject @NamedClient ( \"superheroes\" ) DynamicGraphQLClient client ; // assuming that this system property exists: // superheroes/mp-graphql/url=https://superheroes.org/graphql Programmatically using a builder: DynamicGraphQLClient client = DynamicGraphQLClientBuilder . newBuilder () . url ( \"https://superheroes.org/graphql\" ) . build ();","title":"Initializing the client instance"},{"location":"dynamic-client-usage/#configuration-properties","text":"These properties apply when you\u2019re using CDI to inject named client instances (the first example in the previous section). CLIENT_NAME/mp-graphql/url - defines the URL where the client should connect CLIENT_NAME/mp-graphql/header/KEY - this property declares that the client will add a HTTP header named KEY to all requests (with a value being the value of this property)","title":"Configuration properties"},{"location":"gradle-plugin/","text":"SmallRye GraphQL Gradle plugin This Gradle plugin allows you to generate the GraphQL Schema on build and save it as a text file. Add this to your build.gradle: plugins { id 'io.smallrye.graphql' version '1.0.2-SNAPSHOT' } The schema will appear as build/generated/schema.graphql by default. The plugin\u2019s generateSchema task can customized like: generateSchema { destination = null includeTransitiveDependencies = true includeScalars = true } This will include the project\u2019s dependencies (including the transitive dependencies) to scan for GraphQL model classes. As the destination is set to null the generated schema will only be output to the console and saved to a file. In case external dependencies need to be scanned for GraphQL model classes a more advanced configuration could look like: configrations { graphQLSchema } dependencies { graphQLSchema .. } generateSchema { includeDependencies = true configurations = [\"graphQLSchema\"] } This defines a separate graphQLSchema configuration. In the dependencies block the external dependencies containing the GraphQL mode class should then be registered for the graphQLSchema configuration. The generateSchema task is then customized to only include dependencies from the graphQLSchema configuration. Also note that we set includeDependencies to true (and not includeTransitiveDependencies ). This will make sure only direct dependencies will be be scanned and not possible transitive dependencies. Configuration options destination - To override the default build/generated/schema.graphql destination. includeDependencies - Scan project\u2019s dependencies for GraphQL model classes too. Default false. includeTransitiveDependencies - Scan project\u2019s dependencies (including the transitive dependencies) for GraphQL model classes too. Default false. configurations - If the above includeDependencies or includeTransitiveDependencies is true, you can control what configurations should be included. Default is implementation . dependencyExtensions - If the above includeDependencies or includeTransitiveDependencies is true, you can control what dependency extensions should be included. Default is jar . includeScalars - Include scalars in the schema. Default false. includeDirectives - Include directives in the schema. Default false. includeSchemaDefinition - Include the schema definition. Default false. includeIntrospectionTypes - Include the introspection types in the schema. Default false.","title":"Gradle plugin"},{"location":"gradle-plugin/#smallrye-graphql-gradle-plugin","text":"This Gradle plugin allows you to generate the GraphQL Schema on build and save it as a text file. Add this to your build.gradle: plugins { id 'io.smallrye.graphql' version '1.0.2-SNAPSHOT' } The schema will appear as build/generated/schema.graphql by default. The plugin\u2019s generateSchema task can customized like: generateSchema { destination = null includeTransitiveDependencies = true includeScalars = true } This will include the project\u2019s dependencies (including the transitive dependencies) to scan for GraphQL model classes. As the destination is set to null the generated schema will only be output to the console and saved to a file. In case external dependencies need to be scanned for GraphQL model classes a more advanced configuration could look like: configrations { graphQLSchema } dependencies { graphQLSchema .. } generateSchema { includeDependencies = true configurations = [\"graphQLSchema\"] } This defines a separate graphQLSchema configuration. In the dependencies block the external dependencies containing the GraphQL mode class should then be registered for the graphQLSchema configuration. The generateSchema task is then customized to only include dependencies from the graphQLSchema configuration. Also note that we set includeDependencies to true (and not includeTransitiveDependencies ). This will make sure only direct dependencies will be be scanned and not possible transitive dependencies.","title":"SmallRye GraphQL Gradle plugin"},{"location":"gradle-plugin/#configuration-options","text":"destination - To override the default build/generated/schema.graphql destination. includeDependencies - Scan project\u2019s dependencies for GraphQL model classes too. Default false. includeTransitiveDependencies - Scan project\u2019s dependencies (including the transitive dependencies) for GraphQL model classes too. Default false. configurations - If the above includeDependencies or includeTransitiveDependencies is true, you can control what configurations should be included. Default is implementation . dependencyExtensions - If the above includeDependencies or includeTransitiveDependencies is true, you can control what dependency extensions should be included. Default is jar . includeScalars - Include scalars in the schema. Default false. includeDirectives - Include directives in the schema. Default false. includeSchemaDefinition - Include the schema definition. Default false. includeIntrospectionTypes - Include the introspection types in the schema. Default false.","title":"Configuration options"},{"location":"maven-plugin/","text":"SmallRye GraphQL Maven plugin This Maven plugin allows you to generate the GraphQL Schema on build and save it as a text file. Add this to your pom.xml: <plugin> <artifactId> smallrye-graphql-maven-plugin </artifactId> <groupId> io.smallrye </groupId> <executions> <execution> <goals> <goal> generate-schema </goal> </goals> </execution> </executions> </plugin> The schema will appear as target/generated/schema.graphql by default. The goal is bound to the process-classes build phase. Configuration options destination - To override the default target/generated/schema.graphql destination includeDependencies - Scan project\u2019s dependencies for GraphQL model classes too. This is necessary if your GraphQL endpoint exposes classes that are not in the application's main module. Off ( false ) by default, because scanning a potentially large dependency tree slows down execution substantially. Usage of reactive types does not require turning this option on. includeDependenciesScopes - If the above includeDependencies is true, you can control what scopes should be included. Default is compile, system includeDependenciesTypes - If the above includeDependencies is true, you can control what types should be included. Default is jar includeScalars - Include scalars in the schema. Default false. includeDirectives - Include directives in the schema. Default false. includeSchemaDefinition - Include the schema definition. Default false. includeIntrospectionTypes - Include the introspection types in the schema. Default false. typeAutoNameStrategy - Strategy for transforming class names into GraphQL type names. Valid values are MergeInnerClass , Full and Default .","title":"Maven plugin"},{"location":"maven-plugin/#smallrye-graphql-maven-plugin","text":"This Maven plugin allows you to generate the GraphQL Schema on build and save it as a text file. Add this to your pom.xml: <plugin> <artifactId> smallrye-graphql-maven-plugin </artifactId> <groupId> io.smallrye </groupId> <executions> <execution> <goals> <goal> generate-schema </goal> </goals> </execution> </executions> </plugin> The schema will appear as target/generated/schema.graphql by default. The goal is bound to the process-classes build phase.","title":"SmallRye GraphQL Maven plugin"},{"location":"maven-plugin/#configuration-options","text":"destination - To override the default target/generated/schema.graphql destination includeDependencies - Scan project\u2019s dependencies for GraphQL model classes too. This is necessary if your GraphQL endpoint exposes classes that are not in the application's main module. Off ( false ) by default, because scanning a potentially large dependency tree slows down execution substantially. Usage of reactive types does not require turning this option on. includeDependenciesScopes - If the above includeDependencies is true, you can control what scopes should be included. Default is compile, system includeDependenciesTypes - If the above includeDependencies is true, you can control what types should be included. Default is jar includeScalars - Include scalars in the schema. Default false. includeDirectives - Include directives in the schema. Default false. includeSchemaDefinition - Include the schema definition. Default false. includeIntrospectionTypes - Include the introspection types in the schema. Default false. typeAutoNameStrategy - Strategy for transforming class names into GraphQL type names. Valid values are MergeInnerClass , Full and Default .","title":"Configuration options"},{"location":"power-annotations/","text":"Power Annotations Power-Annotations is actually independent of GraphQL. It\u2019s a generic mechanism for meta annotations. It consists of annotations you can put on your code (these are meant to become a separate standard) and the following implementations: A maven plugin to build a Jandex index file (and resolve all power annotations). This replaces the jandex-maven-plugin . It currently has fewer options, but as we only want to build what people actually need, give us a call if you need more! A classpath scanner to build a Jandex index at runtime (and resolve all power annotations). There\u2019s also a TCK to test, if an implementation adheres to the standard defined by the annotations. It uses an Utils API, so the TCK can also verify implementations not using Jandex. This Annotation Utils API may be convenient for your usage as well, as, e.g., it also resolves repeated annotations. Annotations Stereotypes The simplest use-case for Stereotypes is renaming annotations, e.g. @Property instead of @JsonbProperty (assuming your JSON-B implementation supported Power Annotations). @Retention ( RUNTIME ) @Stereotype @JsonbProperty public @interface Property {} It gets much more interesting, when you add more annotations from other (supporting) frameworks to your stereotype, e.g. @XmlAttribute from JAX-B. Now you have one annotation instead of two with both having the same semantics. Properly used, stereotypes are shortcuts describing the role the annotated element has; functionally as well as a documentation. This is exactly what CDI-Stereotypes do, but not restricted to CDI, i.e. the annotations used by any framework that supports Power Annotations can be used with stereotypes. We have our own Stereotype class; but as we don\u2019t want to depend on CDI and still not exclude CDI, any annotation named Stereotype will work. Mixins Say you have a class you want to add annotations to, but you can\u2019t; e.g., because it\u2019s a class from some library or even from the JDK. You can create your own class (or interface or even annotation) and annotate it as @MixinFor the target class. The annotations you put on your mixin class will work as if they were on the target class (if your framework supports Power Annotations). This also works for annotations: say we\u2019re developing an application packed with annotations from JPA, which doesn\u2019t support mixins (yet). The application also uses a library that supports mixins but doesn\u2019t know about JPA, e.g. libraries like SmallRye GraphQL that use Jandex, and you build the index with the power-jandex-maven-plugin . We want all JPA @Id annotations to be recognized as synonyms for GraphQL @Id annotations. We could create a simple mixin for the JPA annotation: @MixinFor ( javax . persistence . Id . class ) @org.eclipse.microprofile.graphql.Id public class PersistenceIdMixin {} Voil\u00e0! MP GraphQL work as if all JPA @Id annotations were its own. Note Mixins are a very powerful kind of magic: use them with caution and only when strictly necessary. Otherwise, the readers of your code will have a hard time to find out why something behaves as if an annotation was there, but it\u2019s clearly not. If you can, use Stereotypes instead.","title":"Power annotations"},{"location":"power-annotations/#power-annotations","text":"Power-Annotations is actually independent of GraphQL. It\u2019s a generic mechanism for meta annotations. It consists of annotations you can put on your code (these are meant to become a separate standard) and the following implementations: A maven plugin to build a Jandex index file (and resolve all power annotations). This replaces the jandex-maven-plugin . It currently has fewer options, but as we only want to build what people actually need, give us a call if you need more! A classpath scanner to build a Jandex index at runtime (and resolve all power annotations). There\u2019s also a TCK to test, if an implementation adheres to the standard defined by the annotations. It uses an Utils API, so the TCK can also verify implementations not using Jandex. This Annotation Utils API may be convenient for your usage as well, as, e.g., it also resolves repeated annotations.","title":"Power Annotations"},{"location":"power-annotations/#annotations","text":"","title":"Annotations"},{"location":"power-annotations/#stereotypes","text":"The simplest use-case for Stereotypes is renaming annotations, e.g. @Property instead of @JsonbProperty (assuming your JSON-B implementation supported Power Annotations). @Retention ( RUNTIME ) @Stereotype @JsonbProperty public @interface Property {} It gets much more interesting, when you add more annotations from other (supporting) frameworks to your stereotype, e.g. @XmlAttribute from JAX-B. Now you have one annotation instead of two with both having the same semantics. Properly used, stereotypes are shortcuts describing the role the annotated element has; functionally as well as a documentation. This is exactly what CDI-Stereotypes do, but not restricted to CDI, i.e. the annotations used by any framework that supports Power Annotations can be used with stereotypes. We have our own Stereotype class; but as we don\u2019t want to depend on CDI and still not exclude CDI, any annotation named Stereotype will work.","title":"Stereotypes"},{"location":"power-annotations/#mixins","text":"Say you have a class you want to add annotations to, but you can\u2019t; e.g., because it\u2019s a class from some library or even from the JDK. You can create your own class (or interface or even annotation) and annotate it as @MixinFor the target class. The annotations you put on your mixin class will work as if they were on the target class (if your framework supports Power Annotations). This also works for annotations: say we\u2019re developing an application packed with annotations from JPA, which doesn\u2019t support mixins (yet). The application also uses a library that supports mixins but doesn\u2019t know about JPA, e.g. libraries like SmallRye GraphQL that use Jandex, and you build the index with the power-jandex-maven-plugin . We want all JPA @Id annotations to be recognized as synonyms for GraphQL @Id annotations. We could create a simple mixin for the JPA annotation: @MixinFor ( javax . persistence . Id . class ) @org.eclipse.microprofile.graphql.Id public class PersistenceIdMixin {} Voil\u00e0! MP GraphQL work as if all JPA @Id annotations were its own. Note Mixins are a very powerful kind of magic: use them with caution and only when strictly necessary. Otherwise, the readers of your code will have a hard time to find out why something behaves as if an annotation was there, but it\u2019s clearly not. If you can, use Stereotypes instead.","title":"Mixins"},{"location":"server_configuration/","text":"Configuration properties These are properties understood directly by SmallRye GraphQL. If you're using SmallRye GraphQL through Quarkus, these will generally work, but Quarkus offers its own counterparts for most of these, and it is recommended to use the quarkus.* properties. Refer to the Quarkus documentation: Server and Client side Quarkus properties. From MicroProfile GraphQL Property Default value Meaning mp.graphql.defaultErrorMessage Server Error Error message for hidden exceptions mp.graphql.hideErrorMessage Runtime exceptions Exceptions that will be hidden mp.graphql.showErrorMessage Checked exceptions Exceptions that will not be hidden. From SmallRye GraphQL Property Default value Meaning smallrye.graphql.printDataFetcherException false Include the stacktrace of the data fetching exception in the log output smallrye.graphql.allowGet false Allow HTTP GET Method smallrye.graphql.metrics.enabled false Enable metrics smallrye.graphql.tracing.enabled false Enable tracing smallrye.graphql.validation.enabled false Enable Bean Validation smallrye.graphql.events.enabled true if one of metrics, tracing or bean validation is true Enable eventing smallrye.graphql.logPayload false Log the payload in the log file smallrye.graphql.fieldVisibility To control the field visibility on introspection smallrye.graphql.schema.includeScalars true Include Scalar definitions in the schema smallrye.graphql.schema.includeSchemaDefinition false Include Schema definition smallrye.graphql.schema.includeDirectives false Include directives in the schema smallrye.graphql.schema.includeIntrospectionTypes false Include Introspection types in the schema","title":"Server-side configuration"},{"location":"server_configuration/#configuration-properties","text":"These are properties understood directly by SmallRye GraphQL. If you're using SmallRye GraphQL through Quarkus, these will generally work, but Quarkus offers its own counterparts for most of these, and it is recommended to use the quarkus.* properties. Refer to the Quarkus documentation: Server and Client side Quarkus properties.","title":"Configuration properties"},{"location":"server_configuration/#from-microprofile-graphql","text":"Property Default value Meaning mp.graphql.defaultErrorMessage Server Error Error message for hidden exceptions mp.graphql.hideErrorMessage Runtime exceptions Exceptions that will be hidden mp.graphql.showErrorMessage Checked exceptions Exceptions that will not be hidden.","title":"From MicroProfile GraphQL"},{"location":"server_configuration/#from-smallrye-graphql","text":"Property Default value Meaning smallrye.graphql.printDataFetcherException false Include the stacktrace of the data fetching exception in the log output smallrye.graphql.allowGet false Allow HTTP GET Method smallrye.graphql.metrics.enabled false Enable metrics smallrye.graphql.tracing.enabled false Enable tracing smallrye.graphql.validation.enabled false Enable Bean Validation smallrye.graphql.events.enabled true if one of metrics, tracing or bean validation is true Enable eventing smallrye.graphql.logPayload false Log the payload in the log file smallrye.graphql.fieldVisibility To control the field visibility on introspection smallrye.graphql.schema.includeScalars true Include Scalar definitions in the schema smallrye.graphql.schema.includeSchemaDefinition false Include Schema definition smallrye.graphql.schema.includeDirectives false Include directives in the schema smallrye.graphql.schema.includeIntrospectionTypes false Include Introspection types in the schema","title":"From SmallRye GraphQL"},{"location":"typesafe-client-custom-scalars/","text":"Custom scalar types If the remote service contains custom scalar types represented as strings in GraphQL documents, a typesafe client can learn to understand these types through introducing a class that represents them. The class has to contain logic necessary for serializing and deserializing from/to raw strings. A model class is considered to represent a scalar GraphQL type if it contains a static builder method named of , valueOf , or parse whose sole parameter is a java.lang.String and it returns an instance of the class itself. The name of the GraphQL type is assumed to be equal to the short name of the class. For example, if the server supports a URL type (there is a scalar URL clause in the schema), create a class that represents a value for URL : public class URL { private String value ; public URL ( String value ) { this . value = value ; } public static URL valueOf ( String value ) { // <1> return new URL ( value ); } @Override public String toString () { // <2> return value ; } } <1> The static valueOf(String) method will be used for deserializing a URL from a string. <2> The toString() will be used for serializing a URL into a string to be sent to the GraphQL service","title":"Custom scalar types"},{"location":"typesafe-client-custom-scalars/#custom-scalar-types","text":"If the remote service contains custom scalar types represented as strings in GraphQL documents, a typesafe client can learn to understand these types through introducing a class that represents them. The class has to contain logic necessary for serializing and deserializing from/to raw strings. A model class is considered to represent a scalar GraphQL type if it contains a static builder method named of , valueOf , or parse whose sole parameter is a java.lang.String and it returns an instance of the class itself. The name of the GraphQL type is assumed to be equal to the short name of the class. For example, if the server supports a URL type (there is a scalar URL clause in the schema), create a class that represents a value for URL : public class URL { private String value ; public URL ( String value ) { this . value = value ; } public static URL valueOf ( String value ) { // <1> return new URL ( value ); } @Override public String toString () { // <2> return value ; } } <1> The static valueOf(String) method will be used for deserializing a URL from a string. <2> The toString() will be used for serializing a URL into a string to be sent to the GraphQL service","title":"Custom scalar types"},{"location":"typesafe-client-error-handling/","text":"Error handling in typesafe clients If the service returns one or more errors, the client normally throws a GraphQLClientException containing the details in a list of GraphQLClientError . If the error is specific to a location , you can use an ErrorOr wrapper on the target field; the client the maps the error to that wrapper instead of throwing an exception. I.e. your SuperHero class could look like this: class SuperHero { String name ; ErrorOr < Location > location ; } If the service returns a response like this: { \"data\" : { \"superHero\" : { \"name\" : \"Wolverine\" , \"location\" : null } }, \"errors\" : [{ \"message\" : \"location unknown\" , \"path\" : [ \"superHero\" , \"location\" ], \"extensions\" :{ \"code\" : \"location-unknown\" } }] } Then the SuperHero#location wrapper field will not contain a value but only the error above. See the ErrorOr class for details.","title":"Error handling"},{"location":"typesafe-client-error-handling/#error-handling-in-typesafe-clients","text":"If the service returns one or more errors, the client normally throws a GraphQLClientException containing the details in a list of GraphQLClientError . If the error is specific to a location , you can use an ErrorOr wrapper on the target field; the client the maps the error to that wrapper instead of throwing an exception. I.e. your SuperHero class could look like this: class SuperHero { String name ; ErrorOr < Location > location ; } If the service returns a response like this: { \"data\" : { \"superHero\" : { \"name\" : \"Wolverine\" , \"location\" : null } }, \"errors\" : [{ \"message\" : \"location unknown\" , \"path\" : [ \"superHero\" , \"location\" ], \"extensions\" :{ \"code\" : \"location-unknown\" } }] } Then the SuperHero#location wrapper field will not contain a value but only the error above. See the ErrorOr class for details.","title":"Error handling in typesafe clients"},{"location":"typesafe-client-headers/","text":"Adding headers To add a custom header to the http requests sent out by the GraphQL Client, annotate your method or the API interface as @Header , e.g.: @GraphQLClientApi interface SuperHeroesApi { @Header ( name = \"S.H.I.E.L.D.-Clearance\" , constant = \"TOP-SECRET\" ) List < SuperHero > allHeroesIn ( String location ); } The name has to be fixed, but the value can be specified with a constant or the name of a method for dynamic values, e.g.: @GraphQLClientApi interface SuperHeroesApi { @Header ( name = \"S.H.I.E.L.D.-Clearance\" , method = \"establishShieldClearance\" ) List < SuperHero > allHeroesIn ( String location ); static Clearance establishShieldClearance () { return userIsInRole ( MANAGER ) ? TOP_SECRET : PUBLIC ; } } This value is an enum, but it can be any Object; the GraphQL client calls toString() to convert it. The method must be static and accessible by the interface, i.e. in the interface itself or in one of the classes it\u2019s nested in; if it\u2019s in a different class, prefix it with the fully qualified class name and a dot \".\" , e.g. @Header(name = \"S.H.I.E.L.D.-Clearance\", method = \"org.superheroes.SecurityTools.establishShieldClearance\") . A third option is to pass the value of a header as an API method parameter: @GraphQLClientApi interface SuperHeroesApi { List < SuperHero > allHeroesIn ( String location , @Header ( name = \"S.H.I.E.L.D.-Clearance\" ) Clearance clearance ); } The @Header parameter will not part of the GraphQL query. @Header annotations can also be defined via @Stereotype . Authorization headers To add an Authorization header, instead of using the generic @Header annotation, you can also use the special @AuthorizationHeader annotation. It produces a BASIC Authorization header by default or a BEARER token. You can configure the credentials in MP Config with a prefix plus /mp-graphql/ and either username and password for BASIC or bearer for BEARER . The config key defaults to the fully qualified name of the GraphQLClientApi interface or its configKey . You can use a custom prefix by setting the confPrefix . The infix /mp-graphql/ is still applied, unless you end the confPrefix with * , e.g. @AuthorizationHeader(confPrefix = \"org.superheroes.security.basic.* will use org.superheroes.security.basic.username , while * will use plain username . @AuthorizationHeader annotations can be defined via @Stereotype .","title":"Adding headers"},{"location":"typesafe-client-headers/#adding-headers","text":"To add a custom header to the http requests sent out by the GraphQL Client, annotate your method or the API interface as @Header , e.g.: @GraphQLClientApi interface SuperHeroesApi { @Header ( name = \"S.H.I.E.L.D.-Clearance\" , constant = \"TOP-SECRET\" ) List < SuperHero > allHeroesIn ( String location ); } The name has to be fixed, but the value can be specified with a constant or the name of a method for dynamic values, e.g.: @GraphQLClientApi interface SuperHeroesApi { @Header ( name = \"S.H.I.E.L.D.-Clearance\" , method = \"establishShieldClearance\" ) List < SuperHero > allHeroesIn ( String location ); static Clearance establishShieldClearance () { return userIsInRole ( MANAGER ) ? TOP_SECRET : PUBLIC ; } } This value is an enum, but it can be any Object; the GraphQL client calls toString() to convert it. The method must be static and accessible by the interface, i.e. in the interface itself or in one of the classes it\u2019s nested in; if it\u2019s in a different class, prefix it with the fully qualified class name and a dot \".\" , e.g. @Header(name = \"S.H.I.E.L.D.-Clearance\", method = \"org.superheroes.SecurityTools.establishShieldClearance\") . A third option is to pass the value of a header as an API method parameter: @GraphQLClientApi interface SuperHeroesApi { List < SuperHero > allHeroesIn ( String location , @Header ( name = \"S.H.I.E.L.D.-Clearance\" ) Clearance clearance ); } The @Header parameter will not part of the GraphQL query. @Header annotations can also be defined via @Stereotype .","title":"Adding headers"},{"location":"typesafe-client-headers/#authorization-headers","text":"To add an Authorization header, instead of using the generic @Header annotation, you can also use the special @AuthorizationHeader annotation. It produces a BASIC Authorization header by default or a BEARER token. You can configure the credentials in MP Config with a prefix plus /mp-graphql/ and either username and password for BASIC or bearer for BEARER . The config key defaults to the fully qualified name of the GraphQLClientApi interface or its configKey . You can use a custom prefix by setting the confPrefix . The infix /mp-graphql/ is still applied, unless you end the confPrefix with * , e.g. @AuthorizationHeader(confPrefix = \"org.superheroes.security.basic.* will use org.superheroes.security.basic.username , while * will use plain username . @AuthorizationHeader annotations can be defined via @Stereotype .","title":"Authorization headers"},{"location":"typesafe-client-logging/","text":"Logging in typesafe clients The Client implementation logs all GraphQL requests and responses at level INFO with the interface API as the logger name. It also logs the keys of all headers added at level DEBUG ; not the values, as they may be security sensitive.","title":"Logging"},{"location":"typesafe-client-logging/#logging-in-typesafe-clients","text":"The Client implementation logs all GraphQL requests and responses at level INFO with the interface API as the logger name. It also logs the keys of all headers added at level DEBUG ; not the values, as they may be security sensitive.","title":"Logging in typesafe clients"},{"location":"typesafe-client-multiple-queries/","text":"Multiple Say you need the result from several root queries, e.g. all superHeroes and all superVillains . Java only supports a single return value, so you\u2019ll need a wrapper class: @GraphQLClientApi interface SuperHeroesApi { HeroesAndVillains heroesAndVillains (); } @Multiple class HeroesAndVillains { List < SuperHero > superHeroes ; List < SuperVillain > superVillains ; } The @Multiple annotation 'inlines' the wrapper class, i.e. the actual query is: query heroesAndVillains { superHeroes {...} superVillains {...}} The actual response below will be mapped to an instance of the HeroesAndVillains wrapper class: { \"data\" : { \"superHeroes\" : [ ... ], \"superVillains\" : [ ... ] } } If the nested queries require parameters, use @ annotations to put them on the field (remember: GraphQL fields can have parameters). If you need the same request several times (e.g. with different query parameters), use @Name annotations, so the actual field names are used as alias .","title":"Running multiple queries at once"},{"location":"typesafe-client-multiple-queries/#multiple","text":"Say you need the result from several root queries, e.g. all superHeroes and all superVillains . Java only supports a single return value, so you\u2019ll need a wrapper class: @GraphQLClientApi interface SuperHeroesApi { HeroesAndVillains heroesAndVillains (); } @Multiple class HeroesAndVillains { List < SuperHero > superHeroes ; List < SuperVillain > superVillains ; } The @Multiple annotation 'inlines' the wrapper class, i.e. the actual query is: query heroesAndVillains { superHeroes {...} superVillains {...}} The actual response below will be mapped to an instance of the HeroesAndVillains wrapper class: { \"data\" : { \"superHeroes\" : [ ... ], \"superVillains\" : [ ... ] } } If the nested queries require parameters, use @ annotations to put them on the field (remember: GraphQL fields can have parameters). If you need the same request several times (e.g. with different query parameters), use @Name annotations, so the actual field names are used as alias .","title":"Multiple"},{"location":"typesafe-client-reactive-types/","text":"Reactive types usage in typesafe clients Reactive types with queries and mutations Regardless of the type that a query or mutation returns, you can always wrap the return type in a Uni in your @GraphQLClientApi interface. The Uni will be completed after the response is received and processed. Subscriptions The return type of a subscription operation must always be wrapped in a Multi . The communication with the server runs over a WebSocket. Important note about errors When using the typesafe client for subscriptions, if it is expected that the server might return errors, then it is highly recommended to wrap the return types into an ErrorOr (for example, turn the API method @Subscription Multi<Person> people into @Subscription Multi<ErrorOr<Person>> people ). The reason is once there is an error returned from the service and the result can't be turned into a domain object due to that, the Multi will receive a failure as a result. Because of the design of Mutiny, a Multi can't continue producing any items after a failure. That means the subscription will be cancelled after the first error, even though the server might continue sending more items. In such case, your application would have to detect the error and start a new subscription. See Error handling for more details on how to use ErrorOr . Subscription example Given a server-side definition like this: @Subscription public Multi < Integer > countToFive () { return Multi . createFrom (). range ( 0 , 5 ); } A client to consume this subscription can look like this: client . countToFive . subscribe () . with ( // onItem: i -> System . out . println ( \"Received number\" + i ), // onFailure: ( t ) -> t . printStackTrace () );","title":"Reactive"},{"location":"typesafe-client-reactive-types/#reactive-types-usage-in-typesafe-clients","text":"","title":"Reactive types usage in typesafe clients"},{"location":"typesafe-client-reactive-types/#reactive-types-with-queries-and-mutations","text":"Regardless of the type that a query or mutation returns, you can always wrap the return type in a Uni in your @GraphQLClientApi interface. The Uni will be completed after the response is received and processed.","title":"Reactive types with queries and mutations"},{"location":"typesafe-client-reactive-types/#subscriptions","text":"The return type of a subscription operation must always be wrapped in a Multi . The communication with the server runs over a WebSocket.","title":"Subscriptions"},{"location":"typesafe-client-reactive-types/#important-note-about-errors","text":"When using the typesafe client for subscriptions, if it is expected that the server might return errors, then it is highly recommended to wrap the return types into an ErrorOr (for example, turn the API method @Subscription Multi<Person> people into @Subscription Multi<ErrorOr<Person>> people ). The reason is once there is an error returned from the service and the result can't be turned into a domain object due to that, the Multi will receive a failure as a result. Because of the design of Mutiny, a Multi can't continue producing any items after a failure. That means the subscription will be cancelled after the first error, even though the server might continue sending more items. In such case, your application would have to detect the error and start a new subscription. See Error handling for more details on how to use ErrorOr .","title":"Important note about errors"},{"location":"typesafe-client-reactive-types/#subscription-example","text":"Given a server-side definition like this: @Subscription public Multi < Integer > countToFive () { return Multi . createFrom (). range ( 0 , 5 ); } A client to consume this subscription can look like this: client . countToFive . subscribe () . with ( // onItem: i -> System . out . println ( \"Received number\" + i ), // onFailure: ( t ) -> t . printStackTrace () );","title":"Subscription example"},{"location":"typesafe-client-usage/","text":"A Java code-first type-safe GraphQL Client API suggestion for Microprofile GraphQL Issue #185 . Basic Usage Creating the client-side counterpart of the GraphQL API: package examples.typesafeclient ; import io.smallrye.graphql.client.typesafe.api.GraphQLClientApi ; import java.util.List ; @GraphQLClientApi public interface SuperHeroesApi { List < SuperHero > allHeroesIn ( String location ); } A model class: package examples.typesafeclient ; import java.util.List ; public class SuperHero { private String name ; private List < String > superPowers ; // plus getters and setters } Injecting the client using CDI and using it: package examples.typesafeclient ; import javax.inject.Inject ; import java.util.List ; public class MyClientUsage { @Inject SuperHeroesApi superHeroesApi ; public void execute () { List < SuperHero > allHeroes = superHeroesApi . allHeroesIn ( \"Outer Space\" ); // ... } } The default request type is query . To make it a mutation, annotate it @Mutation . The parameter name is only available if you compile the source with the -parameters option. Otherwise, you\u2019ll have to annotate all parameters with @Name . The example above uses CDI, e.g. when you are in a MicroProfile or Jakarta EE environment. If you are in an environment without CDI support, you need to instantiate the API interface by using the builder: SuperHeroesApi api = TypesafeGraphQLClientBuilder . newBuilder (). build ( SuperHeroesApi . class ); The basic idea of the Java code-first approach is that you start by writing the DTOs and query/mutation methods as you need them in your client. This ensures that you don\u2019t request fields that you don\u2019t need; the thinking is inspired by Consumer Driven Contracts . If the server uses names different from yours, you can simply use annotations to do a mapping: Name Mapping / Aliases If the server defines a different field or parameter name, annotate it with @Name . If the server defines a different query name, annotate the method as, e.g., @Query(\"findHeroesCurrentlyLocatedIn\") . By renaming methods, you can also define several variations of the same request but using different return types or parameters. E.g.: public interface SuperHeroesApi { SuperHero findHeroByName ( String name ); @Query ( \"findHeroByName\" ) SuperHeroWithTeams findHeroWithTeamsByName ( String name ); } The SuperHero class has no team affiliations (for this example). The SuperHeroWithTeams class has a List<Team> teamAffiliations field. The actual query name is still findHeroByName . The Team class doesn\u2019t contain the members to break recursion. If you rename a field or method, the real field or method name will be used as an alias, so you can select the same data twice (see and below). Configuration If the endpoint is always the same, e.g. a public API of a cloud service, you can add the URL to your API annotation, e.g.: @GraphQLClientApi ( endpoint = \"https://superheroes.org/graphql\" ) interface SuperHeroesApi { } When instantiating the API with the builder, you can set (or overwrite) the endpoint there: SuperHeroesApi api = TypesafeGraphQLClientBuilder . newBuilder () . endpoint ( \"https://superheroes.org/graphql\" ) . build ( SuperHeroesApi . class ); Commonly you\u2019ll need different endpoints, e.g. when you need one endpoint for your production system, but a different endpoint for your test system. Simply use MicroProfile Config to set the endpoint; similar to the MicroProfile Rest Client , the key for the endpoint is the fully qualified name of the api interface, plus /mp-graphql/url , e.g.: org.superheroes.SuperHeroesApi/mp-graphql/url = https://superheroes.org/graphql If you want to use a different key, set the base config key on the annotation @GraphQLClientApi(configKey = \"superheroes\") ; then use this key for the endpoint superheroes/mp-graphql/url . When using the builder, you can override the config key as well: TypesafeGraphQLClientBuilder.newBuilder().configKey(\"superheroes\") . NestedParameter Some APIs require parameters beyond the root level, e.g. for filtering or paginating nested lists. Say you have a schema like this: type Query { team(name: String!): Team! } type Team { members(first: Int!): [SuperHero!]! } To pass the parameter to the nested field/method, annotate it as @NestedParameter , e.g.: @GraphQLClientApi interface TeamsApi { Team team ( String name , @NestedParameter ( \"members\" ) int first ); } The value of the @NestedParameter annotation is the dot-delimited path to the nested field/method that the value should be added to.","title":"Basic usage"},{"location":"typesafe-client-usage/#basic-usage","text":"Creating the client-side counterpart of the GraphQL API: package examples.typesafeclient ; import io.smallrye.graphql.client.typesafe.api.GraphQLClientApi ; import java.util.List ; @GraphQLClientApi public interface SuperHeroesApi { List < SuperHero > allHeroesIn ( String location ); } A model class: package examples.typesafeclient ; import java.util.List ; public class SuperHero { private String name ; private List < String > superPowers ; // plus getters and setters } Injecting the client using CDI and using it: package examples.typesafeclient ; import javax.inject.Inject ; import java.util.List ; public class MyClientUsage { @Inject SuperHeroesApi superHeroesApi ; public void execute () { List < SuperHero > allHeroes = superHeroesApi . allHeroesIn ( \"Outer Space\" ); // ... } } The default request type is query . To make it a mutation, annotate it @Mutation . The parameter name is only available if you compile the source with the -parameters option. Otherwise, you\u2019ll have to annotate all parameters with @Name . The example above uses CDI, e.g. when you are in a MicroProfile or Jakarta EE environment. If you are in an environment without CDI support, you need to instantiate the API interface by using the builder: SuperHeroesApi api = TypesafeGraphQLClientBuilder . newBuilder (). build ( SuperHeroesApi . class ); The basic idea of the Java code-first approach is that you start by writing the DTOs and query/mutation methods as you need them in your client. This ensures that you don\u2019t request fields that you don\u2019t need; the thinking is inspired by Consumer Driven Contracts . If the server uses names different from yours, you can simply use annotations to do a mapping:","title":"Basic Usage"},{"location":"typesafe-client-usage/#name-mapping-aliases","text":"If the server defines a different field or parameter name, annotate it with @Name . If the server defines a different query name, annotate the method as, e.g., @Query(\"findHeroesCurrentlyLocatedIn\") . By renaming methods, you can also define several variations of the same request but using different return types or parameters. E.g.: public interface SuperHeroesApi { SuperHero findHeroByName ( String name ); @Query ( \"findHeroByName\" ) SuperHeroWithTeams findHeroWithTeamsByName ( String name ); } The SuperHero class has no team affiliations (for this example). The SuperHeroWithTeams class has a List<Team> teamAffiliations field. The actual query name is still findHeroByName . The Team class doesn\u2019t contain the members to break recursion. If you rename a field or method, the real field or method name will be used as an alias, so you can select the same data twice (see and below).","title":"Name Mapping / Aliases"},{"location":"typesafe-client-usage/#configuration","text":"If the endpoint is always the same, e.g. a public API of a cloud service, you can add the URL to your API annotation, e.g.: @GraphQLClientApi ( endpoint = \"https://superheroes.org/graphql\" ) interface SuperHeroesApi { } When instantiating the API with the builder, you can set (or overwrite) the endpoint there: SuperHeroesApi api = TypesafeGraphQLClientBuilder . newBuilder () . endpoint ( \"https://superheroes.org/graphql\" ) . build ( SuperHeroesApi . class ); Commonly you\u2019ll need different endpoints, e.g. when you need one endpoint for your production system, but a different endpoint for your test system. Simply use MicroProfile Config to set the endpoint; similar to the MicroProfile Rest Client , the key for the endpoint is the fully qualified name of the api interface, plus /mp-graphql/url , e.g.: org.superheroes.SuperHeroesApi/mp-graphql/url = https://superheroes.org/graphql If you want to use a different key, set the base config key on the annotation @GraphQLClientApi(configKey = \"superheroes\") ; then use this key for the endpoint superheroes/mp-graphql/url . When using the builder, you can override the config key as well: TypesafeGraphQLClientBuilder.newBuilder().configKey(\"superheroes\") .","title":"Configuration"},{"location":"typesafe-client-usage/#nestedparameter","text":"Some APIs require parameters beyond the root level, e.g. for filtering or paginating nested lists. Say you have a schema like this: type Query { team(name: String!): Team! } type Team { members(first: Int!): [SuperHero!]! } To pass the parameter to the nested field/method, annotate it as @NestedParameter , e.g.: @GraphQLClientApi interface TeamsApi { Team team ( String name , @NestedParameter ( \"members\" ) int first ); } The value of the @NestedParameter annotation is the dot-delimited path to the nested field/method that the value should be added to.","title":"NestedParameter"}]}